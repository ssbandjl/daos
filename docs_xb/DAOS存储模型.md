# 存储模型[¶](https://docs.daos.io/v2.0/overview/storage/#storage-model)

https://docs.daos.io/v2.0/overview/storage/

## 概述[¶](https://docs.daos.io/v2.0/overview/storage/#overview)

下[图](https://docs.daos.io/v2.0/overview/storage/#f4.1)代表了 DAOS 存储模型的基本抽象。

![../graph/daos_abstractions.png](https://docs.daos.io/v2.0/graph/daos_abstractions.png)

DAOS*池*是跨*目标*集合分布的存储预留。每个目标上分配给池的实际空间称为*池*分片。分配给池的总空间在创建时确定。可以通过调整所有池分片的大小（在每个目标专用的存储容量限制内）或跨越更多目标（添加更多池分片）来扩展它。池提供存储虚拟化，是配置和隔离的单元。DAOS 池不能跨越多个系统。

一个池可以托管多个称为 DAOS*容器*的事务对象存储。每个容器都是一个私有对象地址空间，可以事务性地修改它，并且独立于存储在同一池中的其他容器。容器是快照和数据管理的单元。属于容器的 DAOS 对象可以分布在池的任何目标上以提高性能和弹性，并且可以通过不同的 API 访问以有效地表示结构化、半结构化和非结构化数据

下表显示了每个 DAOS 概念的目标可扩展性水平。

| DAOS 概念 | 可扩展性（数量级）                              |
| :-------- | :---------------------------------------------- |
| 系统      | 10 5 个服务器（数十万个）和 10 2 个池（数百个） |
| 服务器    | 10 1 个目标（十个）                             |
| 池        | 10 2 个容器（数百个）                           |
| 容器      | 10 9 个对象（十亿）                             |

## DAOS 池[¶](https://docs.daos.io/v2.0/overview/storage/#daos-pool)

池由唯一的*池 UUID*标识，并在称为*池映射的持久版本列表中维护目标成员资格*. 成员资格是确定的和一致的，成员资格的变化是按顺序编号的。池映射不仅记录活动目标列表，还包含树形存储拓扑，用于识别共享通用硬件组件的目标。例如，树的第一级可以表示共享同一主板的目标，然后第二级可以表示共享同一机架的所有主板，最后第三级可以表示同一机箱中的所有机架。该框架有效地表示分层故障域，然后用于避免将冗余数据放置在遭受相关故障的目标上。在任何时间点，都可以将新目标添加到池映射中，并且可以排除失败的目标。此外，池图是完全版本化的，

池分片是持久内存的保留，可选择与特定目标上的 NVMe 存储上的预分配空间相结合。它具有固定容量，并且在满时无法操作。可以随时查询当前空间使用情况，并报告存储在池分片中的任何数据类型使用的总字节数。

在目标失败并从池映射中排除时，池内的数据冗余会自动在线恢复。这种自我修复过程称为*重建*。重建进度会定期记录在存储在持久内存中的池中的特殊日志中，以解决级联故障。添加新目标时，数据会自动迁移到新添加的目标，以在所有成员之间平均分配空间使用量。此过程称为*空间重新平衡*，并使用专用的持久日志来支持中断和重新启动。池是分布在不同存储节点上的一组目标，数据和元数据分布在这些节点上以实现水平可扩展性，并进行复制或纠删码以确保持久性和可用性。

创建池时，必须定义一组系统属性来配置池支持的不同功能。此外，用户可以定义将永久存储的属性。

只有经过身份验证和授权的应用程序才能访问池。可以支持多种安全框架，从 NFSv4 访问控制列表到基于第三方的身份验证（例如 Kerberos）。连接到池时会强制执行安全性。成功连接到池后，将连接上下文返回给应用程序进程。

如前所述，池存储许多不同类型的持久元数据，例如池映射、身份验证和授权信息、用户属性、属性和重建日志。此类元数据至关重要，需要最高级别的弹性。因此，池元数据被复制到来自不同高级故障域的几个节点上。对于具有数十万个存储节点的非常大的配置，只有很小一部分节点（大约几十个）运行*池元数据服务*。在存储节点数量有限的情况下，DAOS 可以依靠共识算法达成一致，在出现故障的情况下保证一致性，并避免脑裂综合症。

要访问一个池，用户进程应该连接到这个池并通过安全检查。一旦被授予，一个池连接可以与它的任何或所有对等应用程序进程共享（通过`local2global()`和`global2local()`操作）（类似于`openg()`POSIX 扩展）。当在数据中心上运行大规模分布式作业时，这种集体连接机制有助于避免元数据请求风暴。当发出连接请求的原始进程与池断开连接时，池连接将被撤销。



## DAOS 容器[¶](https://docs.daos.io/v2.0/overview/storage/#daos-container)

容器表示池内的对象地址空间，并由*容器 UUID*标识。下图展示了用户（I/O 中间件、特定领域的数据格式、大数据或 AI 框架……）如何使用容器概念来存储相关数据集。

![../graph/containers.png](https://docs.daos.io/v2.0/graph/containers.png)

像池一样，容器可以存储用户属性。必须在容器创建时传递一组属性以配置不同的功能，如校验和。

要访问容器，应用程序必须首先连接到池，然后打开容器。如果应用程序被授权访问容器，则返回容器句柄。这包括授权应用程序中的任何进程访问容器及其内容的功能。打开进程可以与任何或所有对等方共享此句柄。他们的能力在容器关闭时被撤销。

容器中的对象可能具有不同的数据分布模式和目标冗余。动态或静态条带化、复制或纠删码是定义对象模式所需的一些参数。对象类定义一组对象的通用模式属性。每个对象类都分配有一个唯一标识符，并与池级别的给定模式相关联。可以随时使用可配置的模式定义新的对象类，该模式在创建后是不可变的（或至少在属于该类的所有对象都被销毁之前）。为方便起见，在创建池时会默认预定义几个预计最常用的对象类，如下[表](https://docs.daos.io/v2.0/overview/storage/#t4.2)所示。

**预定义对象类示例**

| 对象类别（RW = 读/写，RM = 主要读 | 冗余     | 布局（SC = 条带计数，RC = 副本计数，PC = 奇偶校验计数，TGT = 目标 |
| :-------------------------------- | :------- | :----------------------------------------------------------- |
| 小尺寸&RW                         | 复制     | 静态 SCxRC，例如 1x4                                         |
| 小尺寸 & RM                       | 擦除代码 | 静态 SC+PC，例如 4+2                                         |
| 大尺寸&RW                         | 复制     | 静态 SCxRC 超过最大 #targets）                               |
| 大号&RM                           | 擦除代码 | 静态 SCx(SC+PC) 带最大 #TGT)                                 |
| 未知尺寸和RW                      | 复制     | SCxRC，例如 1x4 最初和增长                                   |
| 尺寸未知 & RM                     | 擦除代码 | SC+PC，例如 4+2 最初和增长                                   |

如下所示，容器中的每个对象都由一个唯一的 128 位*对象地址标识*。对象地址的高 32 位是为 DAOS 保留的，用于对对象类等内部元数据进行编码。剩下的 96 位由用户管理，在容器内应该是唯一的。只要保证唯一性，堆栈的上层可以使用这些位来编码其元数据。DAOS API 中提供了每个容器的 64 位可扩展对象 ID 分配器。应用程序要存储的对象 ID 是完整的 128 位地址，仅供一次性使用，并且只能与单个对象模式关联。

**DAOS 对象 ID 结构**

```
<---------------------------------- 128 bits ---------------------------------->
--------------------------------------------------------------------------------
|DAOS Internal Bits|                Unique User Bits                           |
--------------------------------------------------------------------------------
<---- 32 bits ----><------------------------- 96 bits ------------------------->
```



容器是事务和版本控制的基本单元。*DAOS 库使用称为epoch*的时间戳隐式标记所有对象操作。DAOS 事务 API 允许将多个对象更新组合到单个原子事务中，并具有基于 epoch ordering 的多版本并发控制。所有版本化更新都可以定期 *聚合*，以回收重叠写入使用的空间并降低元数据复杂性。快照是永久引用，可以放置在特定时期以防止聚合。

容器元数据（快照列表、容器打开句柄、对象类、用户属性、属性等）存储在持久内存中，并由专用容器元数据服务维护，该服务使用与父元数据池服务相同的复制引擎，或者有自己的引擎。这在创建容器时是可配置的。

像池一样，对容器的访问由容器句柄控制。要获取有效句柄，应用程序进程必须打开容器并通过安全检查。然后可以通过容器`local2global()`和 `global2local()`操作与其他对等应用程序进程共享此容器句柄。



## DAOS 对象[¶](https://docs.daos.io/v2.0/overview/storage/#daos-object)

为了避免传统存储系统常见的扩展问题和开销，DAOS 对象有意简单。没有提供超出类型和模式的默认对象元数据。这意味着系统不维护时间、大小、所有者、权限甚至跟踪开启者。为了实现高可用性和水平可伸缩性，提供了许多对象模式（复制/纠删码、静态/动态条带化等）。架构框架灵活且易于扩展，以允许将来使用新的自定义架构类型。布局是根据对象标识符和池映射在对象打开的算法上生成的。通过在网络传输和存储期间使用校验和保护对象数据来确保端到端完整性。

可以通过不同的 API 访问 DAOS 对象：

- **多级键数组**API 是具有局部性功能的本机对象接口。密钥分为分布（dkey）和属性（akey）密钥。dkey 和 akey 都可以是可变长度和类型（字符串、整数甚至是复杂的数据结构）。保证同一 dkey 下的所有条目都配置在同一目标上。与 akey 关联的值可以是不能被部分覆盖的单个可变长度值，也可以是固定长度值的数组。akeys 和 dkeys 都支持枚举。
- **Key-value** API 提供了一个简单的键和变长值接口。它支持传统的 put、get、remove 和 list 操作。
- **Array API**实现了一个由 64 位偏移寻址的固定大小元素的一维数组。DAOS 数组支持任意范围的读、写和打孔操作。