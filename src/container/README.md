# DAOS Container

A container represents an object address space inside a pool and is identified by a UUID. To access a container, an application must first connect to the pool and then create or open the container. If the application is authorized to access the container, it obtains a container handle. This includes capabilities that authorize any process in the application to access the container and its contents. The opening process may share this handle with any or all of its peers. Their capabilities are revoked on closing the container.

容器表示池内的对象地址空间，并由 UUID 标识。 要访问容器，应用程序必须首先连接到池，然后创建或打开容器。 如果应用程序被授权访问容器，它会获得一个容器句柄。 这包括授权应用程序中的任何进程访问容器及其内容的功能。 打开过程可以与任何或所有对等点共享此句柄。 他们的能力在关闭容器时被撤销。

<a id="8.1"></a>
## Metadata Layout

The Container Service (`cont_svc`) stores the metadata for containers and provides an API to query and update the state as well as for managing the life-cycle of a container. Container metadata are organized as a hierarchy of key-value stores (KVS) that is replicated over a number of servers backed by Raft consensus protocol which uses strong leadership; client requests can only be serviced by the service leader while non-leader replicas merely respond with a hint pointing to the current leader for the client to retry. `cont_svc` derives from a generic replicated service module `rsvc` (see: <a href="/src/rsvc/README.md#architecture">Replicated Services: Architecture</a>) whose implementation facilitates the client search for the current leader.

容器服务 (cont_svc) 存储容器的元数据，并提供 API 来查询和更新状态以及管理容器的生命周期。 容器元数据被组织为键值存储（KVS）的层次结构，该层次结构在许多服务器上复制，这些服务器由使用强大领导力的 Raft 共识协议支持； 客户端请求只能由服务领导者提供服务，而非领导者副本仅响应指向当前领导者的提示，以便客户端重试。 cont_svc 派生自通用复制服务模块 rsvc（请参阅：复制服务：体系结构），其实现有助于客户端搜索当前领导者。

![Container Service Layout](/docs/graph/Fig_070.png "Container Service Layout")

The top-level KVS `root` has two children:

1. **Containers KVS:** Holds a list of Container Properties KVSs indexed by UUID of the Container which is supplied by the user at the time of creating a new container.
2. **Container Handles KVS:** Used for storing data about container handles opened by various applications and indexed by a handle UUID which is generated by the client at the time of opening a container. The metadata associated with a container handle include its capabilities (e.g., read-only or read-write) and its per-handle epoch state. When a container is closed, the corresponding entry is removed from this store.

顶级 KVS root 有两个孩子：

Containers KVS：包含容器属性 KVS 的列表，该列表由用户在创建新容器时提供的容器 UUID 索引。
Container Handles KVS：用于存储各种应用程序打开的容器句柄数据，由客户端在打开容器时生成的句柄UUID索引。 与容器句柄关联的元数据包括其功能（例如，只读或读写）及其每个句柄的纪元状态。 当容器关闭时，相应的条目将从该存储中删除。



The container properties KVS is used to store per-container metadata that consists of many mutable and immutable scalar valued properties as well as other KVSs as shown in the figure above.

Users can create, delete and retrieve a list of persistent snapshots, which are essentially epochs that will not be aggregated away. A snapshot remains readable until it is explicitly destroyed. A container can also be rolled back to a particular snapshot. (see: <a href="/docs/overview/storage.md#daos-container">Storage Model: DAOS Container</a> and <a href="/docs/overview/transaction.md#container-snapshot">Transaction Model: Container Snapshot</a>).

Users can also define custom attributes for containers which are essentially name-value pairs; with the name being a null-terminated string while the value is an arbitrary sequence of bytes. The Container Service allows clients to retrieve and update multiple attributes at a time as well as to list names of stored attributes.

容器属性 KVS 用于存储每个容器的元数据，这些元数据由许多可变和不可变标量值属性以及其他 KVS 组成，如上图所示。

用户可以创建、删除和检索持久快照列表，这些快照本质上是不会被聚合的时代。 快照在明确销毁之前保持可读。 容器也可以回滚到特定的快照。 （参见：存储模型：DAOS 容器和事务模型：容器快照）。

用户还可以为本质上是名称-值对的容器定义自定义属性； 名称是一个以 null 结尾的字符串，而值是一个任意的字节序列。 容器服务允许客户端一次检索和更新多个属性以及列出存储的属性的名称。

<a id="8.2"></a>

## Target Service (TO BE UPDATED)

The Target Service maps the global object address space of a DAOS container onto the local object address space of a VOS container within the target's VOS pool (vpool), and and calls VOS methods on behalf of the Container Service (see: <a href="/src/vos/README.md#71">VOS Concepts</a>). It caches per-thread information on container objects and open handles in volatile memory for ready access.

目标服务将 DAOS 容器的全局对象地址空间映射到目标 VOS 池 (vpool) 中 VOS 容器的本地对象地址空间，并代表容器服务调用 VOS 方法（请参阅：VOS 概念）。 它在容器对象上缓存每线程信息，并在易失性内存中打开句柄以供访问。

<a id="8.2.1"></a>

#### Target Faults 目标故障

Given hundreds of thousands of targets, the epoch protocol must allow progress in the presence of target faults. Since pool and container services are highly available, the problem is mainly concerned with target services. The solution is based on the assumption that losing some targets may not necessarily cause any application data loss, as there may be enough redundancy created by the DAOS-SR layer to hide the faults from applications. Moreover, an application might even want to ignore a particular data loss (which the DAOS-SR layer is unable to hide), for it has enough application-level redundancy to cope or it simply does not care.

给定数十万个目标，纪元协议必须允许在存在目标故障的情况下取得进展。 由于pool和container服务是高可用的，所以主要是target服务的问题。 该解决方案基于以下假设：丢失某些目标不一定会导致任何应用程序数据丢失，因为 DAOS-SR 层可能会创建足够的冗余来隐藏应用程序的故障。 此外，应用程序甚至可能想要忽略特定的数据丢失（DAOS-SR 层无法隐藏），因为它有足够的应用程序级冗余来应对，或者它根本不在乎。

When a write, flush, or discard operation fails, the DAOS-SR layer calculates if there is sufficient redundancy left to continue with the epoch. If the failure can be hidden, and assuming that the target in question has not already been disabled in the pool map (e.g., as a result of a RAS notification), the DAOS-SR layer must disable the target before committing the epoch. For the epoch protocol, the resulting pool map update effectively records the fact that the target may store an undefined set of write operations in the epoch, and should be avoided. This also applies to applications that would like to ignore similar failures which the DAOS-SR layer cannot hide.

当写入、刷新或丢弃操作失败时，DAOS-SR 层会计算是否有足够的冗余来继续该纪元。 如果故障可以被隐藏，并且假设所讨论的目标尚未在池映射中被禁用（例如，作为 RAS 通知的结果），DAOS-SR 层必须在提交纪元之前禁用目标。 对于纪元协议，生成的池映射更新有效地记录了目标可能在纪元中存储一组未定义的写操作的事实，应该避免。 这也适用于想要忽略 DAOS-SR 层无法隐藏的类似故障的应用程序。

<a id="8.2.2"></a>

#### Object ID Allocator

The OID allocator is a helper routine service that allows users to allocate a unique set of 64 bit unsigned integers within a container. This is helpful for applications or middleware that do not have a way to easily allocate a unique DAOS object ID in a scalable manner. The largest allocated ID is tracked in the Container Properties KVS for future access to that container. This service does not guarantee that the IDs allocated are sequential and several ID ranges may be discarded at container close.

OID 分配器是一个辅助例程服务，允许用户在容器内分配一组唯一的 64 位无符号整数。 这对于无法以可扩展方式轻松分配唯一 DAOS 对象 ID 的应用程序或中间件很有帮助。 最大的分配 ID 在容器属性 KVS 中进行跟踪，以便将来访问该容器。 此服务不保证分配的 ID 是连续的，并且在容器关闭时可能会丢弃多个 ID 范围。

The allocator is implemented using an Incast Variable on the server side that tracks the highest used object ID on a container on the root of the IV tree. A client may request a new allocation from any server running the Container Target Service, i.e. any node in the IV tree. When a new request arrives, the server first checks whether there are any allocated IDs available locally. If not, it forwards a request to the parent (asking for a bigger range of OIDs in that case). The parent does the same check and keeps forwarding to its parent until a request is satisfied or we reach the IV root, which updates the incast variable for the max OID allocated in the container metadata. At each tree level, the number of OIDs asked for is increased to be able to satisfy future OID allocation requests faster.

分配器是使用服务器端的 Incast 变量(IV)实现的，该变量跟踪 IV 树根部容器上使用次数最多的对象 ID。 客户端可以从任何运行容器目标服务的服务器请求新的分配，即 IV 树中的任何节点。 当一个新的请求到达时，服务器首先检查本地是否有可用的分配 ID。 如果不是，它将请求转发给父级（在这种情况下要求更大范围的 OID）。 父级执行相同的检查并继续转发给它的父级，直到请求得到满足或我们到达 IV 根，IV 根更新容器元数据中分配的最大 OID 的 incast 变量。 在每个树级别，请求的 OID 数量都会增加，以便能够更快地满足未来的 OID 分配请求。

<a id="8.3"></a>

## Container Operations

A client creates a new container by sending a `CONT_CREATE` request to the Container Service with the pool handle and a UUID. The client must first establish a pool connection to obtain a pool handle. Optionally, the request can also contain a list of properties to be set on the newly created container. In response, the Container Service creates the corresponding Container Properties KVS with the UUID as the key. Creating a container does not require involvement of the Target Service.

客户端通过使用池句柄和 UUID 向容器服务发送“CONT_CREATE”请求来创建新容器。 客户端必须首先建立池连接以获得池句柄。 可选地，该请求还可以包含要在新创建的容器上设置的属性列表。 作为响应，容器服务以 UUID 为键创建相应的容器属性 KVS。 创建容器不需要目标服务的参与。

Clients may now open a container by supplying the open pool handle and the container UUID along with flags (e.g., read-only or read-write). The client library sends a `CONT_OPEN` request with a locally generated UUID to the Container Service, then use IV(Incast Variable) to broadcast handle asynchronously to all enabled targets in the pool. On successful completion it creates a new entry in the Container Handles KVS.

客户端现在可以通过提供打开的池句柄和容器 UUID 以及标志（例如，只读或读写）来打开容器。 客户端库将带有本地生成的 UUID 的“CONT_OPEN”请求发送到容器服务，然后使用 IV（Incast 变量）将句柄异步广播到池中所有已启用的目标。 成功完成后，它会在 Container Handles KVS 中创建一个新条目。

A client can close a container handle that is no longer needed by sending a `CONT_CLOSE` request to the Container Service which it broadcasts to all enabled targets as a collective `CONT_TGT_CLOSE` in order to close the container handle. It then deletes the corresponding entry from the Container Handles KVS and discards updates performed on the handle that were not committed.

客户端可以通过向容器服务发送“CONT_CLOSE”请求来关闭不再需要的容器句柄，该请求作为一个集体“CONT_TGT_CLOSE”广播到所有启用的目标，以关闭容器句柄。 然后它从 Container Handles KVS 中删除相应的条目，并丢弃对未提交的句柄执行的更新。

A container is destroyed when the client sends a `CONT_DESTROY` request to the Container Service causing it to purge all metadata. Similarly, the targets collectively receive a `CONT_TGT_DESTROY` request from the Container Service and drop all data associated with that container including all the objects within that container. The client can optionally  destroy a container forcibly in case it has handles that are currently open.

当客户端向容器服务发送“CONT_DESTROY”请求导致它清除所有元数据时，容器将被销毁。 类似地，目标共同接收来自容器服务的“CONT_TGT_DESTROY”请求，并删除与该容器关联的所有数据，包括该容器内的所有对象。 客户端可以选择强制销毁容器，以防它有当前打开的句柄。

<a id="8.3.1"></a>

#### Epoch Protocol

The epoch protocol implements the epoch model described in the <a href="/docs/overview/transaction.md">Transaction Model</a>. The Container service manages the epochs of a container; it maintains the definitive epoch state as part of the container metadata, whereas the target services have little knowledge of the global epoch state. Epoch commit, discard, and aggregate procedures are therefore all driven by the container service.

epoch 协议实现了交易模型中描述的 epoch 模型。 容器服务管理容器的时代； 它维护最终的纪元状态作为容器元数据的一部分，而目标服务对全局纪元状态知之甚少。 因此，Epoch 的提交、丢弃和聚合过程都是由容器服务驱动的。

On each target, the target service eagerly stores incoming write operations into the matching VOS container. If a container handle discards an epoch, VOS helps discard all write operations associated with that container handle. When a write operation succeeds, it is immediately visible to conflicting operations in equal or higher epochs. A conflicting write operation with the same epoch will be rejected by VOS unless it is associated with the same container handle and has the same content as the one that is already executed.

在每个目标上，目标服务急切地将传入的写入操作存储到匹配的 VOS 容器中。 如果容器句柄丢弃了一个纪元，VOS 会帮助丢弃与该容器句柄关联的所有写操作。 当写入操作成功时，在相同或更高时期的冲突操作立即可见。 具有相同纪元的冲突写入操作将被 VOS 拒绝，除非它与相同的容器句柄相关联并且与已执行的内容具有相同的内容。

Before committing an epoch, an application must ensure that a sufficient set of write operations for this epoch have been persisted by the target services. The application may decide that losing some write operations is acceptable, depending on the redundancy scheme each of them employs. Committing an epoch of a container handle results in a `CONT_EPOCH_COMMIT` request to the corresponding container service, which simply updates the metadata. When the update becomes persistent, the container service replies to the client with the new epoch state.

在提交一个纪元之前，应用程序必须确保目标服务已经为这个纪元保留了一组足够的写操作。 应用程序可能会决定丢失一些写操作是可以接受的，这取决于它们各自采用的冗余方案。 提交容器句柄的纪元会导致对相应容器服务的“CONT_EPOCH_COMMIT”请求，这只会更新元数据。 当更新变得持久时，容器服务用新的纪元状态回复客户端。
