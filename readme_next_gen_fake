---------------------------- api ----------------------------------
int daos_eq_create(daos_handle_t *eqh);
创建事件队列。 事件队列用于保存和池化多个事件。 创建的每个事件队列都将创建一个与事件队列关联的网络上下文

int set_eq_mode(bool block, bool polling);






-------------------------- app ------------------------------------
static const daos_handle_t eqh; 

daos_eq_create(daos_handle_t *eqh, nolock, noblock);
rados_connect(cluster);
rados_aio_write(test_data.m_ioctx /* rados_ioctx_t */, "foo" /* oid */, my_completion, buf, UINT_MAX /* len */, 0 /* off */));
daos_eq_poll(eqh);
  ... -> my_completion

-------------------------------------------------------------------
int daos_eq_create(daos_handle_t *eqh, bool lock, bool block)
  struct daos_eq_private	*eqx
  struct daos_eq		*eq
  eq = daos_eq_alloc()
    D_INIT_LIST_HEAD(&eq->eq_running)
    D_INIT_LIST_HEAD(&eq->eq_comp)
    daos_hhash_hlink_init(&eqx->eqx_hlink, &eq_h_ops)
  eq.lock=lock;
  eq.block=block;
  rc = crt_context_create(&eqx->eqx_ctx); // block ?
  daos_eq_insert(eqx);
  daos_eq_handle(eqx, eqh);
    daos_hhash_link_key(&eqx->eqx_hlink, &h->cookie) -> 关联key
  rc = tse_sched_init(&eqx->eqx_sched, NULL, eqx->eqx_ctx);

-------------------------------------------------------------------
rados_connect() -> extern "C" int _rados_connect(rados_t cluster) 
  create_cct
  monclient.init()
  monclient.sub_want("mgrmap", 0, 0)
  monclient.renew_subs()
  daos_eq_create | argobots_schedule
  

-------------------------------------------------------------------
rados_aio_write 异步写
CEPH_RADOS_API int rados_aio_write(rados_ioctx_t io, const char *oid, rados_completion_t completion, const char *buf, size_t len, uint64_t off)
  ev
  task
  daos_event_init(&ev, eqh, NULL)
    evx->evx_sched = &eqx->eqx_sched
  ev->de_iov.iov_buf
  ev.cb = NULL;
  prepare_write_op -> CEPH_OSD_OP_WRITE
  tse_task_create(tse_task_func_t task_func, tse_sched_t *sched, void *priv tse_task_t **taskp) -> aio_write
  object_write(*task)
----------------------------- objecter ----------------------------
    check_for_latest_map = _calc_target(&op->target, nullptr)
    add to homeless?
    if(len > 1M)
      split_ec | split_replicate
      tse_task_register_deps
      hrpc_create_req
      tse_task_schedule(*task) -> run task_func
        objecter->op_submit(o, &c->tid)
          hrpc_send

------------------------------ app poll ----------------------------
while(1)
  if(!eq.block)
    rc = daos_eq_poll(eq, 1, DAOS_EQ_WAIT, 128, &dev[0])
    check_homeless_head_timeout
    hrpc_trigger(ctx, hrpc_cb) -> cb
      *task = cb_info
      tse_task_complete
        ev.cb -> completion
    return 0    
  nready = epoll_wait(ctx->event_fd, events, *num_events, timeout_ms)
  rc = daos_eq_poll(eq, 1, DAOS_EQ_WAIT, num_events, &dev[0])
  check_homeless_head_timeout
  hrpc_trigger(ctx, hrpc_cb) -> cb
    *task = cb_info
    tse_task_complete
      ev.cb -> completion
-------------------------------------------------------------------

