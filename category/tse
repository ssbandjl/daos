TSE要点:
参数大小840字节+互斥锁

参数大小:
struct daos_task_args
任务参数 880
TSE_TASK_ARG_LEN
任务参数长度=840+互斥锁(40B) = 880

struct tse_task_private
任务私有参数 1016
TSE_PRIV_SIZE
私有大小=任务参数长度+136
1016

typedef struct tse_task
任务大小 1024
TSE_TASK_SIZE
任务长度=私有+8=1024


/**
 * 给任务携带小参数, 指定参数大小, 获取指定task嵌入的参数, 返回参数地址, 先对输入大小按8字节向上对齐, 计算可用大小(预留内存总大小-栈顶大小), 嵌入大小不能超过可用大小(超过限制返回NULL), 修改嵌入参数大小为指定的大小, 将当前缓冲区地址转为void指针并返回
 *
 *
 * \param task [in] 指定的任务
 * \param size [in] 需要携带参数的字节大小
 *
 * \return	成功返回参数指针, 失败返回NULL
 **/
void * tse_task_buf_embedded(tse_task_t *task, int size);

/**
 * 使用新的任务函数重置任务。 该任务必须已经完成或尚未开始，并且必须具有 > 0 的有效引用计数（未释放）。 这允许用户重用具有不同主体函数的任务，而不必为不同的操作重新创建任务
 *
 *
 * \param task [in] 指定的任务
 * \param task_func [in] 新任务函数
 * \param priv [in] 新任务函数参数
 *
 * \return	成功返回0, 失败返回负数错误码
 **/
int tse_task_reset(tse_task_t *task, tse_task_func_t task_func, void *priv);


/**
 * 将参数, 推入任务堆栈空间。 该API仅在任务堆栈上保留空间，不涉及数据拷贝, 获取可用大小, 输入大小按8字节向上对齐, 将参数大小累加到栈顶指针, 计算新的参数地址(固定地址+总大小-栈顶大小)并返回. 如: 在更新任务中将任务参数压栈 obj_req_valid(task, args, DAOS_OBJ_RPC_UPDATE ...
 *  
 * --------------- dtp_buf_addr 低地址(高地址-低地址是总大小)
 *
 * 
 * --------------- top_new, 返回这个位置的地址(下次从这个位置往下读size大小)
 * size, 这中间放置新参数
 * --------------- top_old
 * 
 * ---------------  高地址
 * 
 * \param task [in] 指定的任务
 * \param size [in] 需要推入参数的字节大小
 *
 * \return	成功返回参数指针, 失败返回NULL
 **/
void * tse_task_stack_push(tse_task_t *task, uint32_t size);


/**
 * 弹出任务参数, 对齐并检测输入的大小, 计算参数地址, 比如在 obj_comp_cb 中拿回携带的任务参数
 *
 * --------------- dtp_buf_addr 低地址(高地址-低地址是总大小)
 *
 * 
 * --------------- top_old, 返回这个位置的地址
 * size, 这中间放置新参数
 * --------------- top_new, top最终的大小在这个位置
 * 
 * --------------- 高地址
 * \param task [in] 指定的任务
 * \param size [in] 需要弹出参数的字节大小
 *
 * \return	成功返回参数指针, 失败返回NULL
 **/
void * tse_task_stack_pop(tse_task_t *task, uint32_t size);


修复: 不安排尚未准备好的即时任务



参数: src/include/daos/tse.h
/* tse_task arguments max length (pthread_mutex_t is of different size between x86 and aarch64). */
#define TSE_TASK_ARG_LEN	(840 + sizeof(pthread_mutex_t))
/* internal tse private data size (struct tse_task_private) */
#define TSE_PRIV_SIZE		(TSE_TASK_ARG_LEN + 136)
/* tse_task is used to track single asynchronous operation (8 bytes used for public members). */
#define TSE_TASK_SIZE		(TSE_PRIV_SIZE + 8)




[root@node215 build]# ./pahole -C tse_task_private  /opt/h3c/lib/libdaos.so.2
die__process_function: tag not supported (INVALID)!
struct tse_task_private {
        struct tse_sched_private * dtp_sched;            /*     0     8 */
        tse_task_func_t            dtp_func;             /*     8     8 */
        d_list_t                   dtp_task_list;        /*    16    16 */
        d_list_t                   dtp_list;             /*    32    16 */
        uint64_t                   dtp_wakeup_time;      /*    48     8 */
        uint64_t                   dtp_create_time;      /*    56     8 */
        /* --- cacheline 1 boundary (64 bytes) --- */
        d_list_t                   dtp_dep_list;         /*    64    16 */
        d_list_t                   dtp_prep_cb_list;     /*    80    16 */
        d_list_t                   dtp_comp_cb_list;     /*    96    16 */
        uint32_t                   dtp_completed:1;      /*   112:31  4 */
        uint32_t                   dtp_running:1;        /*   112:30  4 */
        uint32_t                   dtp_dep_cnt:29;       /*   112: 1  4 */

        /* XXX 1 bit hole, try to pack */

        uint32_t                   dtp_refcnt;           /*   116     4 */
        void *                     dtp_priv;             /*   120     8 */
        /* --- cacheline 2 boundary (128 bytes) --- */
        void *                     dtp_priv_internal;    /*   128     8 */
        uint16_t                   dtp_stack_top;        /*   136     2 */
        uint16_t                   dtp_embed_top;        /*   138     2 */
        uint32_t                   dtp_generation;       /*   140     4 */
        char                       dtp_buf[880];         /*   144   880 */
        /* --- cacheline 16 boundary (1024 bytes) --- */

        /* size: 1024, cachelines: 16, members: 19 */
        /* bit holes: 1, sum bit holes: 1 bits */
}; 




[root@node215 build]#  ./pahole -C daos_task_args  /opt/h3c/lib/libdaos.so.2
die__process_function: tag not supported (INVALID)!
struct daos_task_args {
	uint32_t                   ta_magic;             /*     0     4 */
	uint32_t                   ta_opc;               /*     4     4 */
	union {
		daos_set_params_t  mgmt_set_params;      /*          32 */
		daos_pool_replicas_t pool_add_replicas;  /*          40 */
		daos_pool_replicas_t pool_remove_replicas; /*          40 */
		daos_mgmt_get_bs_state_t mgmt_get_bs_state; /*          32 */
		daos_pool_connect_t pool_connect;        /*          56 */
		daos_pool_disconnect_t pool_disconnect;  /*           8 */
		daos_pool_update_t pool_update;          /*          48 */
		daos_pool_query_t  pool_query;           /*          32 */
		daos_pool_query_target_t pool_query_info; /*          24 */
		daos_pool_list_attr_t pool_list_attr;    /*          24 */
		daos_pool_get_attr_t pool_get_attr;      /*          40 */
		daos_pool_set_attr_t pool_set_attr;      /*          40 */
		daos_pool_stop_svc_t pool_stop_svc;      /*           8 */
		daos_pool_list_cont_t pool_list_cont;    /*          24 */
		daos_cont_create_t cont_create;          /*          40 */
		daos_cont_open_t   cont_open;            /*          56 */
		daos_cont_close_t  cont_close;           /*           8 */
		daos_cont_destroy_t cont_destroy;        /*          40 */
		daos_cont_query_t  cont_query;           /*          24 */
		daos_cont_aggregate_t cont_aggregate;    /*          16 */
		daos_cont_rollback_t cont_rollback;      /*          16 */
		daos_cont_subscribe_t cont_subscribe;    /*          16 */
		daos_cont_list_attr_t cont_list_attr;    /*          24 */
		daos_cont_get_attr_t cont_get_attr;      /*          40 */
		daos_cont_set_attr_t cont_set_attr;      /*          40 */
		daos_cont_alloc_oids_t cont_alloc_oids;  /*          24 */
		daos_cont_list_snap_t cont_list_snap;    /*          40 */
		daos_cont_create_snap_t cont_create_snap; /*          32 */
		daos_cont_destroy_snap_t cont_destroy_snap; /*          24 */
		daos_tx_open_t     tx_open;              /*          24 */
		daos_tx_commit_t   tx_commit;            /*          16 */
		daos_tx_abort_t    tx_abort;             /*           8 */
		daos_tx_close_t    tx_close;             /*           8 */
		daos_tx_restart_t  tx_restart;           /*           8 */
		struct daos_obj_register_class_t obj_reg_class; /*          24 */
		daos_obj_query_class_t obj_query_class;  /*          24 */
		daos_obj_list_class_t obj_list_class;    /*          24 */
		daos_obj_open_t    obj_open;             /*          40 */
		daos_obj_close_t   obj_close;            /*           8 */
		daos_obj_punch_t   obj_punch;            /*          48 */
		daos_obj_query_t   obj_query;            /*          32 */
		daos_obj_query_key_t obj_query_key;      /*          48 */
		struct daos_obj_sync_args obj_sync;      /*          32 */
		daos_obj_fetch_t   obj_fetch;            /*          96 */
		daos_obj_update_t  obj_update;           /*          96 */
		daos_obj_list_dkey_t obj_list_dkey;      /*         136 */
		daos_obj_list_akey_t obj_list_akey;      /*         136 */
		daos_obj_list_recx_t obj_list_recx;      /*         136 */
		daos_obj_list_obj_t obj_list_obj;        /*         136 */
		daos_array_create_t array_create;        /*          56 */
		daos_array_open_t  array_open;           /*          64 */
		daos_array_close_t array_close;          /*           8 */
		daos_array_destroy_t array_destroy;      /*          16 */
		daos_array_io_t    array_io;             /*          40 */
		daos_array_get_size_t array_get_size;    /*          24 */
		daos_array_set_size_t array_set_size;    /*          24 */
		block_io_t         block_io;             /*          48 */
		daos_kv_open_t     kv_open;              /*          40 */
		daos_kv_close_t    kv_close;             /*           8 */
		daos_kv_destroy_t  kv_destroy;           /*          16 */
		daos_kv_get_t      kv_get;               /*          48 */
		daos_kv_put_t      kv_put;               /*          48 */
		daos_kv_remove_t   kv_remove;            /*          32 */
		daos_kv_list_t     kv_list;              /*          48 */
	} ta_u;                                          /*     8   136 */
	/* --- cacheline 2 boundary (128 bytes) was 16 bytes ago --- */
	daos_event_t *             ta_ev;                /*   144     8 */

	/* size: 152, cachelines: 3, members: 4 */
	/* last cacheline: 24 bytes */
};

参数最大880



176B
typedef struct daos_event {
	/** return code of non-blocking operation 非阻塞操作设置的操作码 */
	int			ev_error;
	/** Internal use - 152 + 8 bytes pad for pthread_mutex_t size difference on __aarch64__ */
	struct {
		uint64_t	space[20];
	}			ev_private;
	/** Used for debugging */
	uint64_t		ev_debug;
} daos_event_t;


[root@node215 build]#  ./pahole -C daos_event  /opt/h3c/lib/libdaos.so.2
struct daos_event {
	int                        ev_error;             /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	struct {
		uint64_t           space[19];            /*     8   152 */
		/* --- cacheline 2 boundary (128 bytes) was 24 bytes ago --- */
	} ev_private;                                    /*     8   152 */
	/* --- cacheline 2 boundary (128 bytes) was 32 bytes ago --- */
	uint64_t                   ev_debug;             /*   160     8 */

	/* size: 168, cachelines: 3, members: 3 */
	/* sum members: 164, holes: 1, sum holes: 4 */
	/* last cacheline: 40 bytes */
};




struct daos_event_private {
	daos_handle_t              evx_eqh;              /*     0     8 */
	d_list_t                   evx_link;             /*     8    16 */
	d_list_t                   evx_child;            /*    24    16 */
	unsigned int               evx_nchild;           /*    40     4 */
	unsigned int               evx_nchild_running;   /*    44     4 */
	unsigned int               evx_nchild_comp;      /*    48     4 */
	unsigned int               is_barrier:1;         /*    52:31  4 */
	unsigned int               is_errno:1;           /*    52:30  4 */

	/* XXX 30 bits hole, try to pack */

	unsigned int               evx_flags;            /*    56     4 */
	daos_ev_status_t           evx_status;           /*    60     4 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	struct daos_event_private * evx_parent;          /*    64     8 */
	crt_context_t              evx_ctx;              /*    72     8 */
	struct daos_event_callback evx_callback;         /*    80    24 */
	tse_sched_t *              evx_sched;            /*   104     8 */

	/* size: 112, cachelines: 2, members: 14 */
	/* bit holes: 1, sum bit holes: 30 bits */
	/* last cacheline: 48 bytes */
};

struct daos_eq {
	d_list_t                   eq_comp;              /*     0    16 */
	int                        eq_n_comp;            /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	d_list_t                   eq_running;           /*    24    16 */
	int                        eq_n_running;         /*    40     4 */

	/* XXX 4 bytes hole, try to pack */

	struct {
		uint64_t           space[72];            /*    48   576 */
		/* --- cacheline 9 boundary (576 bytes) --- */
	} eq_private;                                    /*    48   576 */
	/* --- cacheline 9 boundary (576 bytes) was 48 bytes ago --- */

	/* size: 624, cachelines: 10, members: 5 */
	/* sum members: 616, holes: 2, sum holes: 8 */
	/* last cacheline: 48 bytes */
};




